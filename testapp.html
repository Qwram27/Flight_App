<!DOCTYPE html>
<html>
<head>
     <title>Test App</title>
     <style>
          body { margin: 0; background-color: #111; overflow: hidden; }
          canvas { display: block; }
     </style>
</head>
<body>
     <canvas id="screen"></canvas>

     <script>
          // Javaa
          const canvas = document.getElementById('screen');
          const ctx = canvas.getContext('2d');

          // Set the size of canvas to the window size
          canvas.width = window.innerWidth
          canvas.height = window.innerHeight

          // Use (0, 0) as bottom left
          //ctx.translate(0, canvas.height);
          //ctx.scale(1, -1);

          let keys = {};

          let player = {
               pos: {x: 250, y: 500}, // Position
               vel: {x: 0, y: 0}, // Velocity
               angle: 0, // Angle
               mass: 1100, // kg
               wingArea: 20, // m^2
               throttle: 0, // Throttle amount (0-1)
               thrust: 0, // Newtons
               maxThrust: 5000, // Newtons
               airBrake: false, // Air brake
               airBrakeArea: 5, // m^2 Area

          };

          const rho = 1.22 // kg/m^3

          window.addEventListener('mousedown', () => keys['Mouse'] = true);
          window.addEventListener('mouseup', () => keys['Mouse'] = false);

          window.addEventListener('keydown', function(event) {
               if (event.key === "ArrowUp") {
                    keys[event.key] = true;
               }
               if (event.key === "ArrowDown") {
                    keys[event.key] = true;
               }
               
               if (event.key === " ") {
                    player.airBrake = true;
               };

               if (event.key === "ArrowRight" || event.key === "W") {
                    player.throttle = Math.min(player.throttle + 0.05, 1.0);
               }
               if (event.key === "ArrowLeft" || event.key === "S") {
               player.throttle = Math.max(player.throttle - 0.05, 0.0);
               }
          })

          window.addEventListener('keyup', function(event) {
               if (event.key === "ArrowUp") {
                    keys[event.key] = false;
               }
               if (event.key === "ArrowDown") {
                    keys[event.key] = false;
               }
               if (event.key === " ") {
                    player.airBrake = false;
               };
          })

          function update() {

               // 0. Inputs
               let rotationSpeed = 0;

               if (keys.ArrowUp) { rotationSpeed = 0.005; }
               if (keys.ArrowDown) { rotationSpeed -= 0.005; }
               
               player.angle += rotationSpeed;

               // 1. Update the physics
                    // Velocity and Airspeed
                    let v2 = (player.vel.x ** 2) + (player.vel.y ** 2);
                    let speed = Math.sqrt(v2);

                    // Angle of Attack (AoA), angle of the nose relative to movement
                    let flightAngle = speed < 0.1 ? 0: Math.atan2(player.vel.y, player.vel.x);
                    let AoA = player.angle - flightAngle;

                    if (AoA > 0.4) AoA = 0.4;
                    if (AoA < -0.4) AoA = -0.4;

                    // Coefficients
                    let Cl = Math.sin(AoA * 2);
                    let Cd = 0.02 + Math.pow(Cl, 2) / (Math.PI * 7);
                    
                    if (player.airBrake) {
                         Cl *= 0.7; // for now, later wing area?
                         Cd += (player.airBrakeArea / player.wingArea) * 1;
                    }

                    // Force, Lift Equation
                    let liftForce = 0.5 * rho * v2 * player.wingArea * Cl;
                    let dragForce = 0.5 * rho * v2 * player.wingArea * Cd;

                    // Force to X and Y, Lift is always perpendicular to velocity
                    let liftX = -liftForce * Math.sin(flightAngle);
                    let liftY = liftForce * Math.cos(flightAngle);

                    // Drag is always opposite to velocity
                    let dragX = -dragForce * Math.cos(flightAngle);
                    let dragY = -dragForce * Math.sin(flightAngle);

                    // Thrust components
                    player.thrust = player.throttle * player.maxThrust;
                    let thrustX = Math.cos(player.angle) * player.thrust;
                    let thrustY = Math.sin(player.angle) * player.thrust;

                    // Net Forces
                    let totalForceX = thrustX + dragX + liftX;
                    let totalForceY = thrustY + dragY + liftY + (player.mass * -9.81);

                    // Landing Gear
                    if (player.pos.y < 0) {
                         player.pos.y = 0;

                         if (totalForceY < 0) totalForceY = 0;
                         player.vel.y = 0;
                    
                         // Add "Rolling Friction"
                         totalForceX -= player.vel.x * (player.mass * 0.2);
                    }

                    // Acceleration (a = F/m)
                    let ax = totalForceX / player.mass;
                    let ay = totalForceY / player.mass;

                    // Integrate (v = v + a*t)
                    player.vel.x += ax * 1/60;
                    player.vel.y += ay * 1/60;
                    
                    // Update position
                    player.pos.x += player.vel.x;
                    player.pos.y += player.vel.y;

                    //console.log()

               // 2. Logic
               if (player.pos.y > canvas.height - 50) {
                    player.pos.y = canvas.height - 50;
               }

               if (player.pos.x > canvas.width || player.pos.x < 0) {
                    player.pos.x = 0;
               }

               // Rendering
               ctx.clearRect(0, 0, canvas.width, canvas.height);

               // Draw Dashboard (Top Left)
               ctx.save(); // Save state
               ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset scaling/translation for text
               ctx.fillStyle = "white";
               ctx.font = "16px monospace";
               ctx.fillText(`Throttle: ${Math.round(player.throttle * 100)}%`, 20, 30);
               ctx.fillText(`Airspeed: ${Math.round(Math.sqrt(v2))} m/s`, 20, 50);
               ctx.fillText(`Altitude: ${Math.round(player.pos.y)} m`, 20, 70);

               if (player.airBrake) {
                    ctx.fillText(`Airbrake: on`, 20, 90);}
               else {
                         ctx.fillText(`Airbrake: off`, 20, 90);
               }

               ctx.restore(); // Go back to physics coordinates

               ctx.fillStyle = "green";
               ctx.fillRect(0, canvas.height - 10, canvas.width, 10)
               
               let screenX = (canvas.height / 2) - 25;
               let screenY = canvas.height - player.pos.y - 40;

               ctx.fillStyle = "#40AA1A";
               ctx.fillRect(player.pos.x, screenY, 40, 40);

               ctx.strokeStyle = "#40DC22";
               ctx.lineWidth = 5;
               ctx.beginPath();
               ctx.moveTo(player.pos.x + 20, screenY + 20);

               ctx.lineTo(player.pos.x + 20 + Math.cos(player.angle) * 50, screenY + 20 - Math.sin(player.angle) * 50);
               ctx.stroke();

               // Render loop
               requestAnimationFrame(update);
          }

          // Run the engine
          update();
     </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
     <title>Test App</title>
     <style>
          body { margin: 0; background-color: #111; overflow: hidden; }
          canvas { display: block; }
     </style>
</head>
<body>
     <canvas id="screen"></canvas>

     <script>
          // Javaa
          const canvas = document.getElementById('screen');
          const ctx = canvas.getContext('2d');

          const airplaneImg = new Image();
          airplaneImg.src = 'airplane.png';

          // Set the size of canvas to the window size
          canvas.width = window.innerWidth
          canvas.height = window.innerHeight

          let keys = {};

          let player = {
               pos: {x: 250, y: 0}, // Position
               vel: {x: 0, y: 0}, // Velocity
               angle: 0, // Angle
               mass: 1100, // kg
               wingArea: 22, // m^2
               throttle: 0, // Throttle amount (0-1)
               thrust: 0, // Newtons
               maxThrust: 5000, // Newtons
               
               airBrake: false, // Air brake
               airBrakeArea: 5, // m^2 Area

          };

          const rho = 1.22; // kg/m^3
          const WORLD_WIDTH = 2500;
          let cameraX = player.pos.x - (canvas.width * 0.2)
          let cameraY = 0;

          const trees = [
               {x: 100, scale: 1.2},
               {x: 1250, scale: 1.7},
               {x: 1770, scale: 1.5},
               {x: 700, scale: 2},
          ];
          
          function addTree(worldX, scale) {
               let treeX = worldX - cameraX;
               let groundY = (canvas.height - 17) + cameraY

               // Trunk
               ctx.fillStyle = "#462C12";
               let trunkHeight = (scale == 2 ? 40 : 29) * scale;
               ctx.fillRect(treeX, groundY - trunkHeight, 20 * scale, trunkHeight);

               if (scale == 2) {
                    ctx.fillRect(treeX, groundY - trunkHeight + 17, 20 * scale, trunkHeight);}
               else {
                    ctx.fillRect(treeX, groundY - trunkHeight, 20 * scale, trunkHeight);
               }
               
               // Leaf
               ctx.fillStyle = "#27792A";
               ctx.beginPath();
               ctx.moveTo(treeX - (20 * scale), groundY - trunkHeight);
               ctx.lineTo(treeX + (10 * scale), groundY - (150 * scale));
               ctx.lineTo(treeX + (40 * scale), groundY - (29 * scale));
               ctx.fill();
          };

          function loopedX(originalX) {
               let relativeX = (originalX - cameraX) % WORLD_WIDTH
               if (relativeX < -500) relativeX += WORLD_WIDTH;
               return cameraX + relativeX;
          }

          window.addEventListener('mousedown', () => keys['Mouse'] = true);
          window.addEventListener('mouseup', () => keys['Mouse'] = false);

          window.addEventListener('keydown', function(event) {
               if (event.key === "ArrowUp") {
                    keys[event.key] = true;
               }
               if (event.key === "ArrowDown") {
                    keys[event.key] = true;
               }
               
               if (event.key === " ") {
                    player.airBrake = true;
               };

               if (event.key === "ArrowRight" || event.key === "W") {
                    player.throttle = Math.min(player.throttle + 0.05, 1.0);
               }
               if (event.key === "ArrowLeft" || event.key === "S") {
               player.throttle = Math.max(player.throttle - 0.05, 0.0);
               }
          })

          window.addEventListener('keyup', function(event) {
               if (event.key === "ArrowUp") {
                    keys[event.key] = false;
               }
               if (event.key === "ArrowDown") {
                    keys[event.key] = false;
               }
               if (event.key === " ") {
                    player.airBrake = false;
               };
          })

          function update() {

               // 0. Inputs
               let rotationSpeed = 0;

               if (keys.ArrowUp) { rotationSpeed = 0.005; }
               if (keys.ArrowDown) { rotationSpeed -= 0.005; }
               
               player.angle += rotationSpeed;

               // 1. Update the physics
                    // Velocity and Airspeed
                    let v2 = (player.vel.x ** 2) + (player.vel.y ** 2);
                    let speed = Math.sqrt(v2);

                    // Angle of Attack (AoA), angle of the nose relative to movement
                    let flightAngle = speed < 0.1 ? 0: Math.atan2(player.vel.y, player.vel.x);
                    let AoA = player.angle - flightAngle;

                    if (AoA > 0.4) AoA = 0.4;
                    if (AoA < -0.4) AoA = -0.4;
                    
                    if (player.pos.y < 500) {
                         let airEffectiveness = Math.min(speed / 200, 1.0);
                         player.angle -= AoA * 0.02 * airEffectiveness;
                         player.angle *= 0.997;
                    }

                    // Coefficients
                    let Cl = Math.sin(AoA * 2) * 1.2;
                    let Cd = 0.02 + Math.pow(Cl, 2) / (Math.PI * 7);
                    
                    if (player.airBrake) {
                         Cl *= 0.9; // for now, later wing area?
                         Cd += (player.airBrakeArea / player.wingArea) * 1;
                    }

                    // Force, Lift Equation
                    let liftForce = 0.5 * rho * v2 * player.wingArea * Cl;
                    let dragForce = 0.5 * rho * v2 * player.wingArea * Cd;

                    // Force to X and Y, Lift is always perpendicular to velocity
                    let liftX = -liftForce * Math.sin(flightAngle);
                    let liftY = liftForce * Math.cos(flightAngle);

                    // Drag is always opposite to velocity
                    let dragX = -dragForce * Math.cos(flightAngle);
                    let dragY = -dragForce * Math.sin(flightAngle);

                    // Thrust components
                    player.thrust = player.throttle * player.maxThrust;
                    let thrustX = Math.cos(player.angle) * player.thrust;
                    let thrustY = Math.sin(player.angle) * player.thrust;

                    // Net Forces
                    let totalForceX = thrustX + dragX + liftX;
                    let totalForceY = thrustY + dragY + liftY + (player.mass * -9.81);

                    // Landing Gear
                    if (player.pos.y < 0) {
                         player.pos.y = 0;

                         if (totalForceY < 0) totalForceY = 0;
                         player.vel.y = 0;
                    
                         // Add "Rolling Friction"
                         totalForceX -= player.vel.x * (player.mass * 0.2);
                    }

                    // Acceleration (a = F/m)
                    let ax = totalForceX / player.mass;
                    let ay = totalForceY / player.mass;

                    // Integrate (v = v + a*t)
                    player.vel.x += ax * 1/60;
                    player.vel.y += ay * 1/60;
                    
                    // Update position
                    player.pos.x += player.vel.x;
                    player.pos.y += player.vel.y;


               // Rendering
               ctx.clearRect(0, 0, canvas.width, canvas.height);
               
               // Camera Logic
               cameraX = player.pos.x - (canvas.width * 0.2);
               cameraY = 0;

               let followAspect = canvas.height * 0.5;

               if (player.pos.y > followAspect) {
                    cameraY = player.pos.y - followAspect
               }

               let groundY2 = (canvas.height - 17) + cameraY

               let screenX = player.pos.x - cameraX;
               let screenY = canvas.height - (player.pos.y - cameraY) - 40;

               // Grass
               ctx.fillStyle = "green";
               ctx.fillRect(0, groundY2, canvas.width, canvas.height - groundY2 + 500);
               
               // Forest
               for (let i = 0; i < 3; i++) {
                    addTree(loopedX(trees[i].x), trees[i].scale);
               }
               
               // Player
              ctx.save();
              ctx.translate(screenX, screenY);
              ctx.rotate(-player.angle)

              ctx.drawImage(airplaneImg, -50, -50, 200, 100);
              ctx.restore();

               // Tree
               addTree(loopedX(trees[3].x), trees[3].scale);

               // Top left Info
               ctx.save(); // Save state
               ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset scaling/translation for text
               ctx.fillStyle = "white";
               ctx.font = "16px monospace";
               ctx.fillText(`Throttle: ${Math.round(player.throttle * 100)}%`, 20, 30);
               ctx.fillText(`Airspeed: ${Math.round(Math.sqrt(v2))} m/s`, 20, 50);
               ctx.fillText(`Altitude: ${Math.round(player.pos.y)} m`, 20, 70);

               if (player.airBrake) {
                    ctx.fillText(`Airbrake: ON`, 20, 90);}
               else {
                    ctx.fillText(`Airbrake: OFF`, 20, 90);
               }

               ctx.restore();

               // Render loop
               requestAnimationFrame(update);
          }

          // Run the engine
          update();
     </script>
</body>
</html>